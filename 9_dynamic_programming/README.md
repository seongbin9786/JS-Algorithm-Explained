1. 동적 프로그래밍이란
    1. 하위의 작은 문제들을 풀고, 이를 이용해서 더 큰 문제를 풀어나가는 방법이다.
    2. 모든 동적 프로그래밍 알고리즘은 격자(그리드)로부터 시작한다.
    3. 동적 프로그래밍은 점진적으로 답을 수정해나가는 방법이라고 할 수 있다.
    4. 동적 프로그래밍은 제한 조건이 있는 경우에 무언가를 최적화할 때 유용하다.
    5. 격자의 각 칸에는 최적화하려는 값을 쓴다.
    6. 격자의 칸은 하위 문제를 뜻한다. 그러므로 원래의 문제를 어떻게 하위 문제로 나눌 지 생각해야 한다.
    7. 동적 프로그래밍의 해답을 계산해 주는 쉬운 공식은 없다.

2. 배낭 채우기 예시 - 더 작은 배낭에 대한 문제를 풀고 이를 이용해서 원래의 문제를 해결한다.
    1. 격자의 x축을 무게, y축을 들어갈 수 있는 물건이라고 했을 때,
      각 물건의 가격을 기타 - 1500, 스테레오 - 3000, 노트북 - 2000이라고 하면,

        | 물건의 종류 | 1lbs | 2lbs | 3lbs | 4lbs(가방의 무게)
        |-----|----|---|--|---|---|
        |기타|1500|1500|1500|1500 (아직 기타만 넣을 수 있음)
        |스테레오|1500|1500|1500|3000 (기타 혹은 스테레오를 선택할 수 있음)
        |노트북|1500|1500|2000|3500 (노트북, 기타, 스테레오 중 선택할 수 있음)

        위와 같은 표(격자)를 만들 수 있다. 여기서 작은 무게에 대한 최대값(최적해)를 구하는 이유는 이전 무게들의 합이 다음 격자 한 칸의 최대값일 수도 있기 때문이다.

    2. 격자의 각 칸에 들어가는 가치를 계산하는 공식은 다음과 같다: `CELL[i][j]`의 최대값 = `지금까지 구한 cell[i - 1][j]의 값 중에서 가장 최대값` OR `현재 물건의 가치 + 남은 공간 중 최대값(=CELL[i - 1][j - 물건의 무게])`

    3. 새로운 물건이 들어오는 경우, 물건의 종류를 아래에 추가하면 된다. e.g. iPhone - 1lbs - 2000 등, 격자를 내려가면서 새로운 물건의 조합도 계산하기 때문에 어려울 것이 없다.]

        | 물건의 종류 | 1lbs | 2lbs | 3lbs | 4lbs
        |-----|----|---|--|---|---|
        |기타|1500|1500|1500|1500 (아직 기타만 넣을 수 있음)
        |스테레오|1500|1500|1500|3000 (기타 혹은 스테레오를 선택할 수 있음)
        |노트북|1500|1500|2000|3500 (노트북, 기타, 스테레오 중 선택할 수 있음)
        |아이폰|2000|3500|3500|4000 (아이폰, ..., 스테레오 중 선택할 수 있음)

3. 궁금한 점들
    1. 물건을 반대(무거운) 순으로 나열하면 어떻게 될까? 상관 없다.
        | 물건의 종류 | 1lbs | 2lbs | 3lbs | 4lbs
        |-----|----|---|--|---|---|
        |스테레오|0|0|0|3000
        |노트북|0|0|2000|3000
        |아이폰|2000|2000|2000|3000
        |기타|2000|3500|3500|4000

    2. 행, 열을 바꿔도 될까? 이 예제에선 상관 없지만, 다른 문제에서는 달라질 수 있다고 한다.
        | 무게 | 기타 | 아이폰 | 노트북 | 스테레오
        |-----|----|---|--|---|---|
        |1lbs|1500|2000|2000|2000
        |2lbs|1500|3500|3500|3500
        |3lbs|1500|3500|3500|3500
        |4lbs|1500|3500|3500|4000

    3. 더 작은 단위의 물건이 들어오면, 해당 단위로 배낭의 무게 단위가 되어야 한다. e.g. 목걸이 - 0.5lbs - 1000
        | 물건의 종류 | 0.5lbs | 1lbs | 1.5lbs | 2lbs | 2.5lbs | 3lbs | 3.5lbs | 4lbs
        |------------|--------|------|--------|------|--------|------|--------|-----
        |목걸이|1000|1000|1000|1000|1000|1000|1000|1000
        |기타|1000|1500|1500|1500|1500|1500|1500|1500
        |스테레오|1000|1500|2500|2500|2500|2500|2500|3000
        |노트북|1000|1500|2500|2500|2500|2500|2500|3500
        |아이폰|1000|2000|3500|3500|4500|4500|4500|4500

    4. 물건의 일부만 훔칠 수 있을까? `좁쌀 $6 per 1lbs`, `콩 $3 per 1lbs`, `쌀 $2 per lbs` 이면, 좁쌀을 최대한 채워서 훔치는 것이 낫다. 좁쌀을 다 채운 후 나머지를 콩으로 꽉 채우고, 그래도 남으면 쌀로 채우면 된다. 이 문제는 동적 프로그래밍으로 풀지 않는다 :smile: 그리디 알고리즘이다.

4. 여행 일정 최적화 예시 - 배낭 채우기 문제와 똑같다!
    1. 런던으로 가는 여행, 이틀 동안 가능한 한 많은 일들을 경험하고 싶다. 아래는 여행 후보지이다 :sparkles:
        | 관광지 | 소요 시간 | 애착 점수
        |--------|---------|----------
        | 웨스트민스터 사원 | 1/2일 | 7
        | 글로브 극장 | 1/2일 | 6
        | 국립 갤러리 | 1일 | 9
        | 대영 박물관 | 1일 | 9
        | 세인트 폴 대성당 | 1/2일 | 8

    2. 동적 프로그래밍으로 해결하자! 격자 만들기
        | 관광지 | 1/2일 | 1일 | 1 + 1/2일 | 2일
        |-----|----|---|--|---|---|
        |글로브 극장|6|6|6|6
        |웨스트민스터사원|7|13|13|13
        |세인트 폴 대성당|8|15|21|21
        |국립 갤러리|8|9|21|24
        |대영 박물관|8|9|21|24

    3. 파리에 있는 여행지도 가고 싶다. 파리까지 가는 데 시간이 걸리고, 파리에 도착한 이후에는 파리의 여행지를 방문하는 데 들어가는 시간이 줄어든다. 파리에 가는 것까지 고려하게 되면 여행지간에 의존성이 생기는 것인데, 동적 프로그래밍으로는 하위 문제간의 의존성이 있는 경우 문제를 풀 수 없다.

5. 최장 공통 부분 문자열
    1. 두 단어간에 일치하는 부분 문자열의 길이를 측정하는 방법
    2. 원리: 격자를 만들고, x축에는 단어1을, y축에는 단어2를 배치한다.

        |   | H | I | S | H
        |---|---|---|---|---
        | F | 0 | 0 | 0 | 0
        | I | 0 | 1 | 0 | 0
        | S | 0 | 0 | 2 | 0
        | H | 1 | 0 | 0 | 3

    3. 알고리즘
        1. 글자가 다르면 0으로 격자를 채운다.
        2. 글자가 같으면 `CELL[i - 1][j - 1] + 1`으로 격자를 채운다.
        3. 전체 격자 중 가장 큰 값이 공통으로 겹친 문자열(`ish`)의 크기이다.
        4. 코드
            ```js
              if (firstWord[i] == secondWord[j])
                cell[i][j] = cell[i - 1][j - 1] + 1;
              else
                cell[i][j] = 0;
            ```

6. 최장 공통 부분열
    1. 오타를 잡을 때는 최장 공통 부분 문자열을 써봤자 쓸모가 없다.
    2. 공통으로 들어간 글자의 개수를 최대화하는 알고리즘이다.
    3. 위 알고리즘과 다른 점: 모든 격자가 틀려도 이전 셀 값을 보유하기 때문에 같은 글자가 있을 때 마다 값을 올릴 수 있다.
    4. 코드
        ```js
          if (firstWord[i] == secondWord[j])
            cell[i][j] = cell[i - 1][j - 1] + 1;
          else
            cell[i][j] = max(cell[i - 1][j], cell[i][j - 1]);
        ```
